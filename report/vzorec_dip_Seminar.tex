%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% datoteka diploma-vzorec.tex
%
% vzorčna datoteka za pisanje diplomskega dela v formatu LaTeX
% na UL Fakulteti za računalništvo in informatiko
%
% vkup spravil Gašper Fijavž, december 2010
% 
%
%
% verzija 12. februar 2014 (besedilo teme, seznam kratic, popravki Gašper Fijavž)
% verzija 10. marec 2014 (redakcijski popravki Zoran Bosnić)
% verzija 11. marec 2014 (redakcijski popravki Gašper Fijavž)
% verzija 15. april 2014 (pdf/a 1b compliance, not really - just claiming, Damjan Cvetan, Gašper Fijavž)
% verzija 23. april 2014 (privzeto cc licenca)
% verzija 16. september 2014 (odmiki strain od roba)
% verzija 28. oktober 2014 (odstranil vpisno številko)
% verija 5. februar 2015 (Literatura v kazalu, online literatura)
% verzija 25. september 2015 (angl. naslov v izjavi o avtorstvu)
% verzija 26. februar 2016 (UL izjava o avtorstvu)
% verzija 16. april 2016 (odstranjena izjava o avtorstvu)
% verzija 5. junij 2016 (Franc Solina dodal vrstice, ki jih je označil s svojim imenom)


\documentclass[a4paper, 12pt]{book}

\usepackage[utf8x]{inputenc}   % omogoča uporabo slovenskih črk kodiranih v formatu UTF-8
\usepackage[slovene,english]{babel}    % naloži, med drugim, slovenske delilne vzorce
\usepackage[pdftex]{graphicx}  % omogoča vlaganje slik različnih formatov
\graphicspath{ {images/} }
\usepackage{fancyhdr}          % poskrbi, na primer, za glave strani
\usepackage{amssymb}           % dodatni simboli
\usepackage{amsmath}           % eqref, npr.
%\usepackage{hyperxmp}
\usepackage[hyphens]{url}  % dodal Solina
\usepackage{comment}       % dodal Solina

% Psevdokoda %
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}




\usepackage[pdftex, colorlinks=true,
						citecolor=black, filecolor=black, 
						linkcolor=black, urlcolor=black,
						pagebackref=false, 
						pdfproducer={LaTeX}, pdfcreator={LaTeX}, hidelinks]{hyperref}

\usepackage{color}       % dodal Solina
\usepackage{soul}       % dodal Solina

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	DIPLOMA INFO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ttitle}{Simulacija jate ptic}
\newcommand{\ttitleEn}{Flocking simulation}
\newcommand{\tsubject}{\ttitle}
\newcommand{\tsubjectEn}{\ttitleEn}
\newcommand{\tauthor}{Gašper Kolar, Luka Prijatelj}
\newcommand{\tkeywords}{simulacija, jata, ptice, serijski, paralelni, pThreads, OpenMP, OpenCL, MPI}
\newcommand{\tkeywordsEn}{flocking, simulation, serial, parallel, pThreads, OpenMP, OpenCL, MPI}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	HYPERREF SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{pdftitle={\ttitle}}
\hypersetup{pdfsubject=\ttitleEn}
\hypersetup{pdfauthor={\tauthor, gk8384@fri.uni-lj.si}}
\hypersetup{pdfkeywords=\tkeywordsEn}


 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% postavitev strani
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

\addtolength{\marginparwidth}{-20pt} % robovi za tisk
\addtolength{\oddsidemargin}{40pt}
\addtolength{\evensidemargin}{-40pt}

\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami
\setlength{\headheight}{15pt}        % potreben prostor na vrhu
\renewcommand{\chaptermark}[1]%
{\markboth{\MakeUppercase{\thechapter.\ #1}}{}} \renewcommand{\sectionmark}[1]%
{\markright{\MakeUppercase{\thesection.\ #1}}} \renewcommand{\headrulewidth}{0.5pt} \renewcommand{\footrulewidth}{0pt}
\fancyhf{}
\fancyhead[LE,RO]{\sl \thepage} 
%\fancyhead[LO]{\sl \rightmark} \fancyhead[RE]{\sl \leftmark}
\fancyhead[RE]{\sc \tauthor}              % dodal Solina
\fancyhead[LO]{\sc Diplomska naloga}     % dodal Solina


\newcommand{\BibTeX}{{\sc Bib}\TeX}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% naslovi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


\newcommand{\autfont}{\Large}
\newcommand{\titfont}{\LARGE\bf}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\setcounter{tocdepth}{1}	      % globina kazala

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% konstrukti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\newtheorem{izrek}{Izrek}[chapter]
\newtheorem{trditev}{Trditev}[izrek]
\newenvironment{dokaz}{\emph{Dokaz.}\ }{\hspace{\fill}{$\Box$}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PDF-A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% define medatata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\Title{\ttitle}
\def\Author{\tauthor, gk8384@fri.uni-lj.si}
\def\Subject{\ttitleEn}
\def\Keywords{\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \convertDate converts D:20080419103507+02'00' to 2008-04-19T10:35:07+02:00
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\convertDate{%
    \getYear
}

{\catcode`\D=12
 \gdef\getYear D:#1#2#3#4{\edef\xYear{#1#2#3#4}\getMonth}
}
\def\getMonth#1#2{\edef\xMonth{#1#2}\getDay}
\def\getDay#1#2{\edef\xDay{#1#2}\getHour}
\def\getHour#1#2{\edef\xHour{#1#2}\getMin}
\def\getMin#1#2{\edef\xMin{#1#2}\getSec}
\def\getSec#1#2{\edef\xSec{#1#2}\getTZh}
\def\getTZh +#1#2{\edef\xTZh{#1#2}\getTZm}
\def\getTZm '#1#2'{%
    \edef\xTZm{#1#2}%
    \edef\convDate{\xYear-\xMonth-\xDay T\xHour:\xMin:\xSec+\xTZh:\xTZm}%
}

\expandafter\convertDate\pdfcreationdate 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get pdftex version string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newcount\countA
\countA=\pdftexversion
\advance \countA by -100
\def\pdftexVersionStr{pdfTeX-1.\the\countA.\pdftexrevision}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XMP data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\usepackage{xmpincl}
\includexmp{pdfa-1b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pdfInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\pdfinfo{%
    /Title    (\ttitle)
    /Author   (\tauthor)
    /Subject  (\ttitleEn)
    /Keywords (\tkeywordsEn)
    /ModDate  (\pdfcreationdate)
    /Trapped  /False
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\selectlanguage{slovene}
\frontmatter
\setcounter{page}{1} %
\renewcommand{\thepage}{}       % preprecimo težave s številkami strani v kazalu
\newcommand{\sn}[1]{"`#1"'}                    % dodal Solina (slovenski narekovaji)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%naslovnica
 \thispagestyle{empty}%
   \begin{center}
    {\large\sc Univerza v Ljubljani\\%
      Fakulteta za računalništvo in informatiko}%
    \vskip 10em%
    {\autfont \tauthor\par}%
    {\titfont \ttitle \par}%
    {\vskip 3em \textsc{KONČNO POROČILO\\[5mm]         % dodal Solina za ostale študijske programe
%    VISOKOŠOLSKI STROKOVNI ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
    PORAZDELJENI SISTEMI \\ UNIVERZITETNI  ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ RAČUNALNIŠTVO IN MATEMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ UPRAVNA INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ MULTIMEDIJA}\par}%
    \vfill\null%
    %{\large \textsc{Mentor}: doc.\ dr.  Peter Klepec\par}%
   %{\large \textsc{Somentor}:  izr.\ prof.\ dr. Martin Krpan \par}%
    {\vskip 2em \large Ljubljana, 2017 \par}%
\end{center}
% prazna stran
%\clearemptydoublepage      % dodal Solina (izjava o licencah itd. se izpiše na hrbtni strani naslovnice)

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kazalo
\pagestyle{empty}
\def\thepage{}% preprecimo tezave s stevilkami strani v kazalu
\tableofcontents{}

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% povzetek
\addcontentsline{toc}{chapter}{Povzetek}
\chapter*{Povzetek}

\noindent\textbf{Naslov:} \ttitle
\bigskip

\noindent\textbf{Avtor:} \tauthor
\bigskip

%\noindent\textbf{Povzetek:} 
\noindent V vzorcu je predstavljen postopek priprave diplomskega dela z uporabo okolja \LaTeX. Vaš povzetek mora sicer vsebovati približno 100 besed, ta tukaj je odločno prekratek.
\bigskip

\noindent\textbf{Ključne besede:} \tkeywords.
% prazna stran
\clearemptydoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\setcounter{page}{1}
\pagestyle{fancy}

\chapter{Uvod}
Za temo seminarske naloge pri predmetu smo si izbrali simulacijo jate ptic(ang. Flocking simulation).

Vsako iteracijo je potrebno izračunati novo pozicijo za vsako ptico glede na bližnje ptice. Nova pozicija se izračuna glede na 3 preprosta pravila. Ta pravila so ločenost (angl. Separation), usmerjenost (angl. Allignment) in povezanost (angl. Cohesion). Pravilo ločenosti skrbi, da ptice ne letijo preblizu druga drugi. Pravilo usmerjenosti poskrbi, da ptice v jati letijo v isto smer. Pravilo povezanosti pa poskrbi, da se ptice držijo v jati in ne odletijo vsaka v svojo smer. Stanje vsake ptice je opisano z štirimi komponentami - vektor pozicije (X in Y koordinati) ter vektor smeri oz. hitrosti (X in Y koordinati). 

Iz grobe psevdokode \ref{serial_pseudo_code} algoritma je razvidno, da je osnovna serijska implementacija zelo enostavna. Vsako iteracijo se, glede na trenutno stanje, izračuna novo stanje. Novo stanje za vsako ptico se izračuna le glede na lokalne ptice. To so ptice, ki so znotraj določenega radija oddaljenosti od ptice za katero računamo novo stanje. Iskanje lokalnih ptic ima $O(N)$ časovno zahtevnost, kjer je $N$ enak številu vseh ptic v jati. Računanje novega stanje za določeno ptico pa ima časovno zahtevnost enako $O(M)$. Tu je $M$ enak številu lokalnih ptic, ki pa ni nikoli večje od $N$ tako, da je časovna zahtevnost računanja novega stanja za določeno ptico prav tako $O(N)$. Novo stanje pa je potrebno izračunati za vse ptice v jati tako, da je časovna zahtevnost celotnega problema enaka $O(N^2)$. 

Iz psevdokode \ref{serial_pseudo_code} se prav tako vidi, da v pomnilniku hranimo le dve tabeli ptic ki jih vsako iteracijo zamenjamo. Prostorska zahtevnost algorima
\begin{algorithm}
\caption{Groba psevdo koda serijskega algoritma}\label{serial_pseudo_code}
\begin{algorithmic}[1]
\State $N \gets \text{Stevilo ptic}$
\State $trenutnoStanje \gets \textit{ptice[N]}$
\State $naslendjeStanje \gets \textit{ptice[N]}$
\Loop
\For{$i \gets 0; i < N; i++$}
\State $lokalnePtice \gets$ poisciLokalnePtice($trenutnoStanje[i], trenutnoStanje);$
\State $naslendjeStanje[i] \gets$ novoStanje($trenutnoStanje[i], lokalnePtice);$
\EndFor
\State izrisiStanje(naslendjeStanje);
\State $trenutnoStanje \gets naslendjeStanje;$
\EndLoop
\end{algorithmic}
\end{algorithm}

\chapter{Serijska implementacija}
\label{ch1}
\section{Osnovna implementacija}
Razvoj osnovne implementacije ni predstavljal večjih izzivov. Za razvoj smo uporabili Microsoftov Visual Studio 2015 integrirano razvojno okolje, ki se je izkazalo za zelo koristno, posebno pri odpravljanju hroščev. Nekoliko težav smo imeli le z grafičnim izrisovanjem jate ptic. Saj smo se avtorji tokrat privič srečali z grafično knjižnico OpenGL. Poleg OpenGL smo uporabili še GLFW knižnjico, ki poskrbi za kreiranje grafičnega okna. Končen rezulatat je prikazan na Sliki~\ref{img:flocking_simulation_demo}. Po približno 10 sekundah leta so se ptice, iz popolnoma naključnih pozicij združile v jate.

Glavna podatkovna struktura programa je $ptica$. $ptica$ zajema vse podatke ki so potrebni za opis ene ptice v prostoru. To sta torej dva dvo-dimenzionalna vektorja $pozicija$ in $smer$. Struktura $jata$ pa združi vse ptice v tabelo $ptic$.

Serijska implementacija potrebuje kot vhodni podatek le število ptic. Glede na število ptic se ustvari ustrezno velika $jata$.

Ker rezultat vsake iteracije tudi izrišemo na ekran smo se oločili, da bo glavna merska enota število okvirjev na sekundo (ang. Frames per second). Rezultati meritev so tabelirani v Tabela~\ref{tabela_meritev_serijskih_alg}. Ker smo bili nad rezultati nekoliko razočarani smo se odločili algoritem pohitriti z mrežo.

\begin{figure}[t]
\includegraphics[width=\textwidth]{flocking_simulation_demo}
\caption{Slika je bila zajeta po približno 10 sekundah prostega leta. Ptice so se združile v jate.}
\label{img:flocking_simulation_demo}
\centering
\end{figure}

\section{Implementacija z mrežo}
Zaradi relativno poraznih rezultatov smo se odločili, da serijski algoritem pohitrimo. To smo naredili z implementacijo nove podatkovne strukture mreža (ang. Grid). Iz popravljene psevdokode \ref{serial_grid_pseudo_code} algoritma je razvidno, da se vsako iteracijo ptice najprej razporedi v mrežo na to pa se izračunajo nova stanja ptic. Mreža je ilustrirana na Sliki~\ref{img:flocking_simulation_grid}. Velikost celice je določena z doložino lokalnosti. To je maksimalna razdalja med pticama, ki še vedno vplivata druga na drugo. Za računanje novih stanj ptic v neki celici so tako potrebne le ptice v isti in sosednjih celicah. Uporabi se 8-kratna sosednost. Tako znatno pohitrimo izvajanje algoritma saj ni več potrebno iskati lokalnih ptic.

Rezultati meritev so tabelirani v Tabela~\ref{tabela_meritev_serijskih_alg}. Algoritem z mrežo je opazno hitrejši. Pri 1000 pticah je algoritem z mrežo skoraj 6 krat hitrejši. Meritve so vizualizirane na Slika~\ref{img:graf_serial_alg}

\begin{figure}[t]
\includegraphics[width=\textwidth]{flocking_simulation_grid}
\caption{Ilustracija mrežne. Za računanje nove pozicije se uporabi 8-kratna sosednjost. To pomeni, da se za izračun novi stanj ptic v celici $e$ uporabijo ptice iz celic $a, b, c, d, e, f, g, h, i$}
\label{img:flocking_simulation_grid}
\centering
\end{figure}

\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\textbf{Velikost jate} & \textbf{Serijski algoritem {[}FPS{]}} & \textbf{Serijski algoritem z mrežo{[}FPS{]}} \\ \hline
100 & 653,222 & 1533,090 \\
200 & 526,485 & 1347,730 \\
300 & 390,755 & 1096,380 \\
400 & 276,068 & 922,016 \\
500 & 194,607 & 774,890 \\
600 & 149,196 & 658,868 \\
700 & 120,471 & 537,585 \\
800 & 100,174 & 465,814 \\
900 & 84.070 & 441,535 \\
1000 & 71,061 & 419,116 \\ \hline
\end{tabular}%
}
\caption{Primerjava števila okvirjev na sekundo (ang. Frames per second) v odvisnosti od velikosti jate za serijski algoritem in serijski algoritem z mrežo}
\label{tabela_meritev_serijskih_alg}
\end{table}

\begin{figure}[t]
\includegraphics[width=\textwidth]{graf_serial_alg}
\caption{Graf primerja število okvirjev na sekundo za serijski algoritem z in brez mreže v odvisnosti od velikosti jate.}
\label{img:graf_serial_alg}
\centering
\end{figure}

\begin{algorithm}
\caption{Groba psevdo koda serijskega algoritma z uporabo mreže}\label{serial_grid_pseudo_code}
\begin{algorithmic}[1]
\State $N \gets \text{Stevilo ptic}$
\State $trenutnoStanje \gets \textit{ptice[N]}$
\State $naslendjeStanje \gets \textit{ptice[N]}$
\Loop
\State $mrezaPtic \gets$ razporediPticeVMrezo($trenutnoStanje);$
\For{$i \gets 0; i < N; i++$}
\State $naslendjeStanje[i] \gets$ novoStanje($trenutnoStanje[i], mrezaPtic);$
\EndFor
\State izrisiStanje(naslendjeStanje);
\State $trenutnoStanje \gets naslendjeStanje;$
\EndLoop
\end{algorithmic}
\end{algorithm}

\chapter{Paralelna implementacija z uporabo pThreads}
\label{ch2}
Prva paralelna implementacija algoritma uporablja pThreads za nitenje. Kot izhodišče za implementacijo smo uporabili serijski algoritem z mrežo. Implementacija je grobo opisana v psevdokodi \ref{paralel_pthreads_pseudo_code}. Vsako iteraciji glavna nit ptice razporedi v mrežo. Nato pa se ustvarijo posamezne niti, ki izračunajo novo stanje jate. Komunikacije med nitmi ni potrebna saj vsaka nit dobi podatke o vseh pticah v jati. Ko niti kočnajo računanje se pridružijo glavni niti, da ta izriše novo stanje na ekran.

Meritve algoritma so tabelirane v Tabela~\ref{tabela_meritev_pthreads}. Razberemo lahko, da smo z paralelizacijo dosegli pohitritev. Ta je bila največja pri štirih nitih in se je večala z številom ptic. Učinkovitost se je prav tako večala z število ptic a je bila ta največja pri dveh nitih. Razlog za to je najverjetneja strojna oprema saj ima procesor le 2 jedri. Meritve smo izvajali na prenosnem računalniki z \textit{Intel i7 – 5500U 2.40GHz} procesorjem in \textit{16GB} pomnilnika. Meritve so vizualizirane v grafu na Slika~\ref{img:graf_pthreads}.

\begin{algorithm}
\caption{Groba psevdo koda paralelnega algoritma z uporabo pThreads}\label{paralel_pthreads_pseudo_code}
\begin{algorithmic}[1]
\State $N \gets \text{Število ptic}$
\State $P \gets \text{Število niti}$
\State $trenutnoStanje \gets \textit{ptice[N]}$
\State $naslendjeStanje \gets \textit{ptice[N]}$
\Loop
\State $mrezaPtic \gets$ razporediPticeVMrezo($trenutnoStanje);$
\For{$i \gets 0; i < P; i++$}
\State ustvariNit($i, N, trenutnoStanje, naslendjeStanje, mrezaPtic);$
\EndFor
\For{$i \gets 0; i < P; i++$}
\State pridruziNit($i);$
\EndFor
\State izrisiStanje(naslendjeStanje);
\State $trenutnoStanje \gets naslendjeStanje;$
\EndLoop
\end{algorithmic}
\end{algorithm}


\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|l|lll|lll|lll|}
\cline{2-11}
 & \multicolumn{1}{c|}{\textbf{Serijski}} & \multicolumn{3}{c|}{\textbf{pThreads - 2 niti}} & \multicolumn{3}{c|}{\textbf{pThreads - 4 niti}} & \multicolumn{3}{c|}{\textbf{pThreads - 8 niti}} \\ \cline{1-1}
\multicolumn{1}{|l|}{\textbf{Velikost jate}} & FPS & FPS & S & E & FPS & S & E & FPS & S & E \\ \hline
\multicolumn{1}{|l|}{1000} & 419,12 & 401,96 & 0,96 & 0,48 & 437,63 & 1,04 & 0,26 & 409,84 & 0,98 & 0,12 \\
\multicolumn{1}{|l|}{1200} & 354,73 & 349,46 & 0,99 & 0,49 & 379,77 & 1,07 & 0,27 & 363,85 & 1,03 & 0,13 \\
\multicolumn{1}{|l|}{1400} & 296,02 & 311,61 & 1,05 & 0,53 & 312,54 & 1,06 & 0,26 & 331,14 & 1,12 & 0,14 \\
\multicolumn{1}{|l|}{1600} & 249,40 & 274,55 & 1,10 & 0,55 & 258,45 & 1,04 & 0,26 & 270,84 & 1,09 & 0,14 \\
\multicolumn{1}{|l|}{1800} & 216,03 & 242,16 & 1,12 & 0,56 & 232,21 & 1,07 & 0,27 & 225,42 & 1,04 & 0,13 \\
\multicolumn{1}{|l|}{2000} & 186,09 & 217,36 & 1,17 & 0,58 & 210,56 & 1,13 & 0,28 & 204,04 & 1,10 & 0,14 \\
\multicolumn{1}{|l|}{2200} & 163,80 & 195,88 & 1,20 & 0,60 & 191,45 & 1,17 & 0,29 & 184,85 & 1,13 & 0,14 \\
\multicolumn{1}{|l|}{2400} & 143,49 & 170,23 & 1,19 & 0,59 & 177,42 & 1,24 & 0,31 & 169,70 & 1,18 & 0,15 \\
\multicolumn{1}{|l|}{2600} & 129,57 & 146,25 & 1,13 & 0,56 & 160,77 & 1,24 & 0,31 & 155,48 & 1,20 & 0,15 \\
\multicolumn{1}{|l|}{2800} & 116,04 & 134,75 & 1,16 & 0,58 & 147,77 & 1,27 & 0,32 & 143,54 & 1,24 & 0,15 \\ \hline
\end{tabular}%
}
\caption{Meritve za pThreads paralelni algoritem. FPS predstvlja število okvirjev na sekundo, S predstavlja pohitritev, E pa predstavlja učinkovitos.}
\label{tabela_meritev_pthreads}
\end{table}

\begin{figure}[t]
\includegraphics[width=\textwidth]{graf_pthreads}
\caption{Graf primerja paralelni pThreads algoritem z serijskim algorimom v odvisnosti od velikosti jate.}
\label{img:graf_pthreads}
\centering
\end{figure}

\chapter{Paralelna implementacija z uporabo OpenMP}
\label{ch3}
Naslednja paralelna implementacija uporabla OpenMP za nitenje. Zaradi narave OpenMP-ja je bilo ta algoritem najlažje implementirati. Kot izhodišče smo spet uporabili serijski algoritem z mrežo. Kot je moč razbrati iz psevdokode~\ref{openmp_pseudo_code} je bila za implementacijo potrebna le ena pragma. Tu smo probali tudi z paralelizacijo notranje zanke, toraj tiste znotraj funnkicje novoStanje, ki iterira čez lokalne ptice. Ampak se je taka implementacija izkazala za veliko počasnejšo tako, da smo uporabili to z le eno pragmo.

Meritve algoritma so tabelirane v Tabela~\ref{tabela_meritev_openmp}. Tako kot prejšne meritve so bile izmerjene na prenosnem računalniku z \textit{Intel i7 – 5500U 2.40GHz} procesorjem in \textit{16GB} pomnilnika. Meritve so vizualizirane v grafu na Slika~\ref{img:graf_pthreads}. Rezultati so nekoliko slabši od pThreads algoritma. Pri osmih nitih nam celo ni uspelo doseči pohitritve. Vsaj ne pri izmerjenih velikosti jat. Se pa je pohitritev, tako kot pri pThreads implementaciji, večala z velikostjo jate tako, da bi pohitritev dosegli pri večji jati ptic. Pri dveh in štirih nitih pa je OpenMP popolnoma primerljiv z pThreads implementacijo.

\begin{algorithm}
\caption{Groba psevdo koda paralelnega OpenMP algoritma}\label{openmp_pseudo_code}
\begin{algorithmic}[1]
\State $N \gets \text{Stevilo ptic}$
\State $trenutnoStanje \gets \textit{ptice[N]}$
\State $naslendjeStanje \gets \textit{ptice[N]}$
\Loop
\State $mrezaPtic \gets$ razporediPticeVMrezo($trenutnoStanje);$
\State \#pragma omp parallel for
\For{$i \gets 0; i < N; i++$}
\State $naslendjeStanje[i] \gets$ novoStanje($trenutnoStanje[i], mrezaPtic);$
\EndFor
\State izrisiStanje(naslendjeStanje);
\State $trenutnoStanje \gets naslendjeStanje;$
\EndLoop
\end{algorithmic}
\end{algorithm}

\begin{table}[]
\centering
\label{tabela_meritev_openmp}
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|l|lll|lll|lll|}
\cline{2-11}
 & \multicolumn{1}{c|}{\textbf{Serijski}} & \multicolumn{3}{c|}{\textbf{OpenMP - 2 niti}} & \multicolumn{3}{c|}{\textbf{OpenMP - 4 niti}} & \multicolumn{3}{c|}{\textbf{OpenMP - 8 niti}} \\ \cline{1-1}
\multicolumn{1}{|l|}{\textbf{Velikost jate}} & FPS & FPS & S & E & FPS & S & E & FPS & S & E \\ \hline
\multicolumn{1}{|l|}{1000} & 419,116 & 451,419 & 1,077 & 0,539 & 358,913 & 0,856 & 0,214 & 355,986 & 0,849 & 0,106 \\
\multicolumn{1}{|l|}{1200} & 354,729 & 404,158 & 1,139 & 0,570 & 306,139 & 0,863 & 0,216 & 306,216 & 0,863 & 0,108 \\
\multicolumn{1}{|l|}{1400} & 296,022 & 342,132 & 1,156 & 0,578 & 269,892 & 0,912 & 0,228 & 271,292 & 0,916 & 0,115 \\
\multicolumn{1}{|l|}{1600} & 249,400 & 292,425 & 1,173 & 0,586 & 239,009 & 0,958 & 0,240 & 231,754 & 0,929 & 0,116 \\
\multicolumn{1}{|l|}{1800} & 216,027 & 232,414 & 1,076 & 0,538 & 215,714 & 0,999 & 0,250 & 183,616 & 0,850 & 0,106 \\
\multicolumn{1}{|l|}{2000} & 186,088 & 195,283 & 1,049 & 0,525 & 194,283 & 1,044 & 0,261 & 164,767 & 0,885 & 0,111 \\
\multicolumn{1}{|l|}{2200} & 163,803 & 174,330 & 1,064 & 0,532 & 132,147 & 0,807 & 0,202 & 145,796 & 0,890 & 0,111 \\
\multicolumn{1}{|l|}{2400} & 143,485 & 158,778 & 1,107 & 0,553 & 141,602 & 0,987 & 0,247 & 131,347 & 0,915 & 0,114 \\
\multicolumn{1}{|l|}{2600} & 129,574 & 145,168 & 1,120 & 0,560 & 126,673 & 0,978 & 0,244 & 120,304 & 0,928 & 0,116 \\
\multicolumn{1}{|l|}{2800} & 116,038 & 130,722 & 1,127 & 0,563 & 118,434 & 1,021 & 0,255 & 113,196 & 0,976 & 0,122 \\ \hline
\end{tabular}%
}
\caption{Meritve za OpenMP paralelni algoritem. FPS predstvlja število okvirjev na sekundo, S predstavlja pohitritev, E pa predstavlja učinkovitos.}
\end{table}

\begin{figure}[t]
\includegraphics[width=\textwidth]{graf_openmp}
\caption{Graf primerja paralelni OpenMP algoritem z serijskim algorimom v odvisnosti od velikosti jate.}
\label{img:graf_openmp}
\centering
\end{figure}

\chapter{Paralelna implementacija z uporabo OpenCL}
\label{ch4}
Pri serijskem algoritmu smo imeli na voljo 1 nit, ki je bila zadolžena za celotno računanje. Nato smo uporabili knjižnici pThread in OpenMP. Ti dve knjižnici sta nam omogočili ustvarjanje in upravljanje z nitmi. Tako smo imeli na testnih računalnikih lahko 2, 4 in 8 niti, ki so znatno pohitrile čas računanja. Nato pa je sledila še knjižnica OpenCL. OpenCL je knjižnica, ki lahko prevede in požene program na grafični kartici. To je v našem primeru pomenilo, da smo lahko 8 niti zamenjali z 640 delovnimi elementi (nitmi). Seveda se arhitektura grafične kartice zelo razlikuje od arhitekture procesorja in zato procesorske niti ne moremo enačiti z nitmi na grafični kartici. Procesorska arhitektura namreč omogoča izvrševanje ukazov v zaporednem vrstnem redu. Ta arhitektura je v primerjavi z arhitekturo grafične kartice čisto drugačna. Grafična kartica namreč deluje tako, da vsako njeno jedro vzporedno z drugimi jedri izvršuje ukaze. 

Na začetku vsakega računanja na grafični kartici, se podatki morajo vedno prenesejo iz glavnega pomninika na pomnilnik grafične kartice. To lahko pri večjem številu ptic zelo upočasni čas računanja. Da bi pohitrili prenašanje podatkov, smo se odločili, da podatke prenesemo le enkrat. To se zgodi ob prvi iteraciji, ko zaženemo program na grafični kartici. Ko se prva iteracija konča, grafična kartica prenese rezultate v glavni pomnilnik, svoje podatke pa obdrži v svojem pomnilniku. Tako lahko za naslednjo iteracijo uporabi kar svoje stare podatke in jih ne potrebuje ponovno prenašati iz glavnega pomnilnika.

Ker v našem primeru skorajda ne potrebujemo komunikacije med jedri grafične kartice, je to področje kjer se grafična kartica zelo dobro izkaže. Hitrost računanja grafične kartice je bila mnogo hitrejša od računanja na procesorju, kar se še posebno lepo pokaže pri večjem številu ptic. To lahko opazimo v Tabeli~\ref{tabela_meritev_opencl} ali pa na Sliki~\ref{img:graf_opencl}. Pri 2800 pticah smo dosegli kar 3,36 kratno pohitritev. Kar je največja pohitritev, ki smo jo uspeli doseči s katerokoli arhitekturo.

\begin{table}[]
\centering
\resizebox{8cm}{!}{%
\begin{tabular}{l|l|lll|}
\cline{2-5}
 & \multicolumn{1}{c|}{\textbf{Serijski}} & \multicolumn{3}{c|}{\textbf{OpenCL - 640 niti}} \\ \cline{1-1}
\multicolumn{1}{|l|}{\textbf{Velikost jate}} & FPS & FPS & S & E \\ \hline
\multicolumn{1}{|l|}{1000} & 419,1160 & 826,0000 & 1,9708 & 0,0031 \\
\multicolumn{1}{|l|}{1200} & 354,7290 & 761,0000 & 2,1453 & 0,0034 \\
\multicolumn{1}{|l|}{1400} & 296,0220 & 676,0000 & 2,2836 & 0,0036 \\
\multicolumn{1}{|l|}{1600} & 249,4000 & 605,0000 & 2,4258 & 0,0038 \\
\multicolumn{1}{|l|}{1800} & 216,0270 & 556,0000 & 2,5738 & 0,0040 \\
\multicolumn{1}{|l|}{2000} & 186,0880 & 516,0000 & 2,7729 & 0,0043 \\
\multicolumn{1}{|l|}{2200} & 163,8030 & 471,0000 & 2,8754 & 0,0045 \\
\multicolumn{1}{|l|}{2400} & 143,4850 & 440,0000 & 3,0665 & 0,0048 \\
\multicolumn{1}{|l|}{2600} & 129,5740 & 418,0000 & 3,2260 & 0,0050 \\
\multicolumn{1}{|l|}{2800} & 116,0380 & 390,0000 & 3,3610 & 0,0053 \\ \hline
\end{tabular}%
}
\caption{Primerjava števila okvirjev na sekundo (ang. Frames per second) v odvisnosti od velikosti jate za serijski algoritem in OpenCL algoritmom}
\label{tabela_meritev_opencl}
\end{table}


\begin{figure}[t]
\includegraphics[width=\textwidth]{graf_opencl}
\caption{Graf primerja število okvirjev na sekundo za serijski algoritem z mrežo in OpenCL algoritmom v odvisnosti od velikosti jate.}
\label{img:graf_opencl}
\centering
\end{figure}

\chapter{Paralelna implementacija z uporabo MPI}
\label{ch5}
TODO...

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|l|lll|lll|}
\cline{2-8}
 & \multicolumn{1}{c|}{\textbf{Serijski}} & \multicolumn{3}{c|}{\textbf{MPI - 2 niti}} & \multicolumn{3}{c|}{\textbf{MPI - 4 niti}} \\ \cline{1-1}
\multicolumn{1}{|l|}{\textbf{Velikost jate}} & FPS & FPS & S & E & FPS & S & E \\ \hline
\multicolumn{1}{|l|}{1000} & 419,12 & 386,30 & 0,92 & 0,46 & 309,44 & 0,74 & 0,18 \\
\multicolumn{1}{|l|}{1200} & 354,73 & 316,19 & 0,89 & 0,45 & 275,97 & 0,78 & 0,19 \\
\multicolumn{1}{|l|}{1400} & 296,02 & 293,20 & 0,99 & 0,50 & 245,19 & 0,83 & 0,21 \\
\multicolumn{1}{|l|}{1600} & 249,40 & 245,02 & 0,98 & 0,49 & 218,18 & 0,87 & 0,22 \\
\multicolumn{1}{|l|}{1800} & 216,03 & 244,74 & 1,13 & 0,57 & 192,51 & 0,89 & 0,22 \\
\multicolumn{1}{|l|}{2000} & 186,09 & 210,07 & 1,13 & 0,56 & 180,12 & 0,97 & 0,24 \\
\multicolumn{1}{|l|}{2200} & 163,80 & 171,62 & 1,05 & 0,52 & 166,15 & 1,01 & 0,25 \\
\multicolumn{1}{|l|}{2400} & 143,49 & 162,31 & 1,13 & 0,57 & 151,85 & 1,06 & 0,26 \\
\multicolumn{1}{|l|}{2600} & 129,57 & 138,84 & 1,07 & 0,54 & 139,74 & 1,08 & 0,27 \\
\multicolumn{1}{|l|}{2800} & 116,04 & 137,38 & 1,18 & 0,59 & 128,19 & 1,10 & 0,28 \\ \hline
\end{tabular}%
}
\end{table}

\begin{figure}[t]
\includegraphics[width=\textwidth]{graf_mpi}
\caption{TODO...}
\label{img:graf_mpi}
\centering
\end{figure}

\clearpage
\addcontentsline{toc}{chapter}{Literatura}
\bibliographystyle{plain}
\bibliography{literatura}


\end{document}

